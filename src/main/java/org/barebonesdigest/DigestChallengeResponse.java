package org.barebonesdigest;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

/**
 * Describes the contents of an {@code Authorization} HTTP request header. Once the client has
 * received a HTTP Digest challenge from the server this header should be included in all subsequent
 * requests to authorize the client.
 * <p>
 * Instances of this class is normally created as a response to an incoming challenge using
 * {@link #responseTo(DigestChallenge)}. To generate the {@code Authorization} header, som
 * additional values must be set:
 * <ul>
 * <li>The {@link #username(String) username} and {@link #password(String) password} for
 * authentication.</li>
 * <li>The {@link #digestUri(String) digestUri} used in the HTTP request.</li>
 * <li>The {@link #requestMethod(String) request method} of the request, such as "GET" or "POST".
 * </li>
 * </ul>
 * <p>
 *
 * Here is an example of how to create a response:
 * <pre>
 * {@code
 * DigestChallengeResponse response = DigestChallengeResponse.responseTo(challenge)
 *                                                           .username("user")
 *                                                           .password("passwd")
 *                                                           .digestUri("/example")
 *                                                           .requestMethod("GET");
 * }
 * </pre>
 *
 * <h2>Challenge response reuse</h2>
 *
 * A challenge response from an earlier challenge can be reused in subsequent requests. If the
 * server accepts the reused challenge this will cut down on unnecessary traffic.
 * <p>
 * Each time the challenge response is reused the nonce count must be increased by one, see
 * {@link #incrementNonceCount()}.
 *
 * <h2>Limitations</h2>
 *
 * <ul>
 * <li>Only the MD5 algorithm is supported, not MD5-sess.</li>
 * <li>qop is always set to auth. THe value from the challenge is not used. auth-int qop is not
 * supported.</li>
 * </ul>
 *
 * @see <a href="https://tools.ietf.org/html/rfc2617#section-3.2.2">RFC 2617, "HTTP Digest Access
 * Authentication", Section 3.2.2, "The Authorization Request Header"</a>
 */
public class DigestChallengeResponse {
  /**
   * The name of the HTTP request header ({@value #HTTP_HEADER_AUTHORIZATION}).
   */
  public static final String HTTP_HEADER_AUTHORIZATION = "Authorization";

  private static final int CLIENT_NONCE_BYTE_COUNT = 8;
  private static final SecureRandom RANDOM = new SecureRandom();
  private static byte[] clientNonceByteBuffer = new byte[CLIENT_NONCE_BYTE_COUNT];

  private final MessageDigest md5;

  private String algorithm;
  private String username;
  private String password;
  private String clientNonce;
  private String quotedNonce;
  private int nonceCount;
  private String quotedOpaque;
  private String digestUri;
  private String quotedRealm;
  private String requestMethod;

  /**
   * Creates an empty challenge response.
   */
  public DigestChallengeResponse() {
    try {
      this.md5 = MessageDigest.getInstance("MD5");
    } catch (NoSuchAlgorithmException e) {
      // TODO find out if this can happen
      throw new RuntimeException(e);
    }

    this.nonceCount(1);
  }

  /**
   * Creates a digest challenge response, setting the {@code realm} and the values of the {@code
   * nonce}, {@code opaque}, and {@code algorithm} directives based on a challenge.
   *
   * @param challenge the challenge
   * @return a response to the challenge.
   */
  public static DigestChallengeResponse responseTo(DigestChallenge challenge) {
    return new DigestChallengeResponse().challenge(challenge);
  }

  /**
   * Sets the {@code algorithm} directive, which must be the same as the {@code algorithm} directive
   * of the challenge. The only value currently supported is "MD5".
   *
   * @param algorithm the value of the algorithm directive
   * @return this object so that setters can be chained
   * @see <a href="https://tools.ietf.org/html/rfc2617#section-3.2.2">Section 3.2.2 of RFC 2617</a>
   */
  public DigestChallengeResponse algorithm(String algorithm) {
    if (!"MD5".equals(algorithm)) {
      throw new IllegalArgumentException("Unsupported algorithm: " + algorithm);
    }

    this.algorithm = algorithm;
    return this;
  }

  /**
   * Sets the username to use for authentication.
   *
   * @return this object so that setters can be chained
   * @see <a href="https://tools.ietf.org/html/rfc2617#section-3.2.2">Section 3.2.2 of RFC 2617</a>
   */
  public DigestChallengeResponse username(String username) {
    this.username = username;
    return this;
  }

  /**
   * Sets the password to use for authentication.
   *
   * @param password the password
   * @return this object so that setters can be chained
   */
  public DigestChallengeResponse password(String password) {
    this.password = password;
    return this;
  }

  /**
   * Sets the {@code cnonce} directive, which is a random string generated by the client that will
   * be included in the challenge response hash.
   * <p/>
   * There is normally no need to manually set the client nonce since it will have a default value
   * of a randomly generated string.
   *
   * @param clientNonce the unquoted value of the cnoncedirective
   * @return this object so that setters can be chained
   * @see <a href="https://tools.ietf.org/html/rfc2617#section-3.2.2">Section 3.2.2 of RFC 2617</a>
   */
  public DigestChallengeResponse clientNonce(String clientNonce) {
    this.clientNonce = clientNonce;
    return this;
  }

  /**
   * Sets the {@code nonce} directive, which must be the same as the nonce directive of the
   * challenge.
   * <p/>
   * Setting the {@code nonce} directive resets the nonce count to one.
   *
   * @param quotedNonce the quoted value of the nonce directive
   * @return this object so that setters can be chained
   * @see <a href="https://tools.ietf.org/html/rfc2617#section-3.2.2">Section 3.2.2 of RFC 2617</a>
   * @see #nonce(String)
   */
  public DigestChallengeResponse quotedNonce(String quotedNonce) {
    this.quotedNonce = quotedNonce;
    resetNonceCount();
    return this;
  }

  /**
   * Sets the {@code nonce} directive, which must be the same as the {@code nonce} directive of the
   * challenge.
   * <p/>
   * Setting the nonce directive resets the nonce count to one.
   *
   * @param unquotedNonce the unquoted value of the nonce directive
   * @return this object so that setters can be chained
   * @see <a href="https://tools.ietf.org/html/rfc2617#section-3.2.2">Section 3.2.2 of RFC 2617</a>
   * @see #quotedNonce(String)
   */
  public DigestChallengeResponse nonce(String unquotedNonce) {
    return quotedNonce(Rfc2616AbnfParser.quote(unquotedNonce));
  }

  /**
   * Sets the integer representation of the {@code nonce-count} directive, which indicates how many
   * times this a challenge response with this nonce has been used.
   * <p>
   * This is useful when using a challenge response from a previous challenge when sending a
   * request. For each time a challenge response is used, the nonce count should be increased by
   * one.
   *
   * @param nonceCount integer representation of the {@code nonce-count} directive
   * @return this object so that setters can be chained
   * @see #resetNonceCount()
   * @see #incrementNonceCount()
   * @see <a href="https://tools.ietf.org/html/rfc2617#section-3.2.2">Section 3.2.2 of RFC 2617</a>
   */
  public DigestChallengeResponse nonceCount(int nonceCount) {
    this.nonceCount = nonceCount;
    return this;
  }

  /**
   * Sets the {@code opaque} directive, which must be the same as the {@code opaque} directive of
   * the challenge.
   *
   * @param quotedOpaque the quoted value of the opaque directive, or {@code null} if no
   *                     opaque directive should be included in the challenge response
   * @return this object so that setters can be chained
   * @see <a href="https://tools.ietf.org/html/rfc2617#section-3.2.2">Section 3.2.2 of RFC 2617</a>
   * @see #opaque(String)
   */
  public DigestChallengeResponse quotedOpaque(String quotedOpaque) {
    this.quotedOpaque = quotedOpaque;
    return this;
  }

  /**
   * Sets the {@code opaque} directive, which must be the same as the {@code opaque} directive of
   * the challenge.
   * <p>
   * Note: Since the value of the {@code opaque} directive is always received from a challenge
   * quoted it is normally better to use the {@link #quotedOpaque(String)} method to avoid
   * unnecessary quoting/unquoting.
   *
   * @param unquotedOpaque the unquoted value of the opaque directive, or {@code null} if no
   *                       opaque directive should be included in the challenge response
   * @return this object so that setters can be chained
   * @see <a href="https://tools.ietf.org/html/rfc2617#section-3.2.2">Section 3.2.2 of RFC 2617</a>
   * @see #quotedOpaque
   */
  public DigestChallengeResponse opaque(String unquotedOpaque) {
    return quotedOpaque(Rfc2616AbnfParser.quote(unquotedOpaque));
  }

  /**
   * Sets the {@code digest-uri} directive, which must be exactly the same as the
   * {@code Request-URI} of the {@code Request-Line} of the HTTP request.
   * <p>
   * The digest URI is explained in
   * <a href="https://tools.ietf.org/html/rfc2617#section-3.2.2">Section 3.2.2 of RFC 2617</a>,
   * and refers to the explanation of Request-URI found in
   * <a href="https://tools.ietf.org/html/rfc2616#section-5.1.2">Section 5.1.2 of RFC 2616</a>.
   * <p>
   * Examples: If the {@code Request-Line} is
   * <pre>
   * GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.1
   * </pre>
   * the {@code Request-URI} (and {@code digest-uri}) is "{@code
   * http://www.w3.org/pub/WWW/TheProject.html}". If {@code Request-Line} is
   * <pre>
   * GET /pub/WWW/TheProject.html HTTP/1.1
   * </pre>
   * the {@code Request-URI} is "{@code /pub/WWW/TheProject.html}".
   * <p>
   * This can be problematic since depending on the HTTP stack being used the {@code Request-Line}
   * and {@code Request-URI} values may not be accessible. If in doubt, a sensible guess is to set
   * the {@code digest-uri} to the path part of the URL being requested, for instance using
   * <a href="https://developer.android.com/reference/java/net/URL.html#getPath()">
   * <code>getPath()</code> in the <code>URL</code> class</a>.
   *
   * @param digestUri the value of the digest-uri directive
   * @return this object so that setters can be chained
   */
  public DigestChallengeResponse digestUri(String digestUri) {
    this.digestUri = digestUri;
    return this;
  }

  public DigestChallengeResponse quotedRealm(String quotedRealm) {
    this.quotedRealm = quotedRealm;
    return this;
  }

  public DigestChallengeResponse realm(String unquotedRealm) {
    return quotedRealm(Rfc2616AbnfParser.quote(unquotedRealm));
  }

  public DigestChallengeResponse requestMethod(String requestMethod) {
    this.requestMethod = requestMethod;
    return this;
  }

  /**
   * Sets the {@code realm} and the values of the {@code nonce}, {@code opaque}, and
   * {@code algorithm} directives based on a challenge.
   *
   * @param challenge the challenge
   * @return this object so that setters can be chained
   */
  public DigestChallengeResponse challenge(DigestChallenge challenge) {
    return quotedNonce(challenge.getQuotedNonce()).quotedOpaque(challenge.getQuotedOpaque())
        .quotedRealm(challenge.getQuotedRealm())
        .algorithm(challenge.getAlgorithm());
  }

  public String getAlgorithm() {
    return algorithm;
  }

  public String getUsername() {
    return username;
  }

  public String getPassword() {
    return password;
  }

  public String getClientNonce() {
    if (clientNonce == null) {
      synchronized (this) {
        if (clientNonce == null) {
          clientNonce = generateRandomNonce();
        }
      }
    }

    return clientNonce;
  }

  public String getQuotedNonce() {
    return quotedNonce;
  }

  public String getNonce() {
    // TODO: Cache since value is used each time a header is written
    return Rfc2616AbnfParser.unquote(quotedNonce);
  }

  public int getNonceCount() {
    return nonceCount;
  }

  public void resetNonceCount() {
    nonceCount(1);
  }

  public void incrementNonceCount() {
    nonceCount(nonceCount + 1);
  }

  public String getQuotedOpaque() {
    return quotedOpaque;
  }

  public String getOpaque() {
    return Rfc2616AbnfParser.unquote(quotedOpaque);
  }

  public String getDigestUri() {
    return digestUri;
  }

  public String getQuotedRealm() {
    return quotedRealm;
  }

  public String getRealm() {
    // TODO: Cache since value is used each time a header is written
    return Rfc2616AbnfParser.unquote(quotedRealm);
  }

  public String getRequestMethod() {
    return requestMethod;
  }

  public String getHeaderValue() {
    // TODO: verify that all values are set

    String response = calculateResponse();

    StringBuilder result = new StringBuilder();
    result.append("Digest ");

    // Username is defined in Section 3.2.2 of RFC 2617
    // username         = "username" "=" username-value
    // username-value   = quoted-string
    result.append("username=");
    result.append(Rfc2616AbnfParser.quote(username));
    result.append(",");

    // Realm is defined in RFC 2617, Section 1.2
    // realm       = "realm" "=" realm-value
    // realm-value = quoted-string
    result.append("realm=");
    result.append(quotedRealm);
    result.append(",");

    // nonce             = "nonce" "=" nonce-value
    // nonce-value       = quoted-string
    result.append("nonce=");
    result.append(quotedNonce);
    result.append(",");

    // digest-uri       = "uri" "=" digest-uri-value
    // digest-uri-value = request-uri   ; As specified by HTTP/1.1
    result.append("uri=");
    result.append(Rfc2616AbnfParser.quote(digestUri));
    result.append(",");

    // Response is defined in RFC 2617, Section 3.2.2 and 3.2.2.1
    // response         = "response" "=" request-digest
    result.append("response=");
    result.append(response);
    result.append(",");

    // Cnonce is defined in RFC 2617, Section 3.2.2
    // cnonce           = "cnonce" "=" cnonce-value
    // cnonce-value     = nonce-value
    // Must be present if qop is specified, must not if qop is unspecified
    // TODO: don't include if qop is unspecified
    result.append("cnonce=");
    result.append(Rfc2616AbnfParser.quote(getClientNonce()));
    result.append(",");

    // Opaque and algorithm are explained in Section 3.2.2 of RFC 2617:
    // "The values of the opaque and algorithm fields must be those supplied
    // in the WWW-Authenticate response header for the entity being
    // requested."

    if (quotedOpaque != null) {
      result.append("opaque=");
      result.append(quotedOpaque);
      result.append(",");
    }

    if (algorithm != null) {
      result.append("algorithm=");
      result.append(algorithm);
      result.append(",");
    }

    // TODO Verify that server supports auth
    // TODO Also support auth-int
    result.append("qop=auth");
    result.append(",");

    // Nonce count is defined in RFC 2617, Section 3.2.2
    // nonce-count      = "nc" "=" nc-value
    // nc-value         = 8LHEX (lower case hex)
    // Must be present if qop is specified, must not if qop is unspecified
    result.append("nc=");
    result.append(String.format("%08x", nonceCount));

    return result.toString();
  }

  private String calculateResponse() {
    // TODO: Below calculation is for the case where qop is present, if not qop is calculated
    // differently
    String a1 = calculateA1();
    String a2 = calculateA2();

    String secret = calculateMd5(a1);
    String data = joinWithColon(getNonce(),
        String.format("%08x", nonceCount),
        getClientNonce(),
        "auth",
        calculateMd5(a2));

    return "\"" + calculateMd5(secret + ":" + data) + "\"";
  }

  private String calculateA1() {
    // TODO: Below calculation is for if algorithm is MD5 or unspecified
    // TODO: Support MD5-sess algorithm
    return joinWithColon(username, getRealm(), password);
  }

  private String calculateA2() {
    // TODO: Below calculation if if qop is auth or unspecified
    // TODO: Support auth-int qop
    return joinWithColon(requestMethod, digestUri);
  }

  private String joinWithColon(String... parts) {
    StringBuilder result = new StringBuilder();

    for (String part : parts) {
      if (result.length() > 0) {
        result.append(":");
      }
      result.append(part);
    }

    return result.toString();
  }

  private String calculateMd5(String string) {
    md5.reset();
    // TODO find out which encoding to use
    md5.update(string.getBytes());
    return encodeHexString(md5.digest());
  }

  private static String encodeHexString(byte[] bytes) {
    StringBuilder result = new StringBuilder(bytes.length * 2);
    for (int i = 0; i < bytes.length; i++) {
      result.append(Integer.toHexString((bytes[i] & 0xf0) >> 4));
      result.append(Integer.toHexString((bytes[i] & 0x0f)));
    }
    return result.toString();
  }

  private static synchronized String generateRandomNonce() {
    RANDOM.nextBytes(clientNonceByteBuffer);
    return encodeHexString(clientNonceByteBuffer);
  }
}
